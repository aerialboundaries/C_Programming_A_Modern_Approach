/* C Programming A Modern Approach Ch03 exercise1.txt */

Q: What output do the following call of printf produce?
(a): printf ("%6d, %4d", 86, 1040);
(b): printf("%12.5e", 30.253);
(c): printf("%.4f", 83.162);
(d): printf("%-6.2g", .0000009979);
---------------------------------------
My answer;

(a): "    86", "1040"
(b): "     30253e-3"
(c): "83.1620"

-----------------------------------------
gccの結果
$ ./a.out 
    86, 1040
 3.02530e+01
83.1620
1e-06

-------------------------------------------
Gemini の指摘
指数表記は必ず整数部分は一桁


printf("%-6.2g", .0000009979);
🔍 1e-06 が表示される理由
printf の %g 変換指定子は、有効数字の指定 .2（2桁）と組み合わさるときに四捨五入を行います。

1. 値の丸め処理
元の値: 0.0000009979（または 9.979×10 
−7
 ）

有効数字2桁の境界: 1.000×10 
−6
  の直前。

有効数字2桁に丸める:

有効数字2桁で表現すると、9.9 または 1.0 のどちらかになります。

9.979... は、有効数字2桁で表す次の桁（3桁目）が 7 であり、5 以上であるため、切り上げが行われます。

切り上げの結果: 10.0×10 
−7
 

指数表記の正規化: これは 1.0×10 
−6
 、つまり 1e−06 になります。

2. 書式指定子の適用
要素	適用
精度 .2	値を有効数字2桁に丸めた結果、1e-06 に決定。
出力:	1e-06 は 5文字 です。
幅 -6	幅6で左寄せ（-）ですが、出力が5文字なので、右側にスペース1つがパディングされます。

Google スプレッドシートにエクスポート
最終的な表示（コンソール出力）
1e-06 
（1e-06 の後にスペースが1つ入っています）

💡 まとめ
前の回答で得られた 9.9e-07 は有効数字2桁の切り捨てに近い処理に基づくものであり、今回ご提示の 1e-06 は標準Cライブラリの丸め処理（最も近い値への丸め）が適用された、より正確な結果です。

特に %g 形式では、このように有効数字の指定が指数部の切り替えを引き起こすことがあります。
