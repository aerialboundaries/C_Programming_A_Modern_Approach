/* C Programming A Modern Approach ex5-2.c
 *
 * The following program fragments illustrate the logical operators.  Show the
 * output produced by each, assuming that i, j and k are int variables.
 *
 * (a) i = 10; j = 5;
 * printf("%d\n", !i < j);
 *
 * (b) i = 2; j = 1;
 *     printf("%d\n", !!i + !j);
 *
 * (c) i = 5; j = 0; k = -5;
 *     printf("%d\n", i && j || k);
 *
 * (d) i = 1; j = 2; k = 3;
 *     printf("%d\n", i < j || k);
 *
 * My Answers:
 * (a) 1
 * (b) 1
 * (c) 1
 * (d) 1

 *お持ちの教科書『C Programming: A Modern Approach』の ex5-2
の問題と、あなたの回答を拝見しました。論理演算子の優先順位と C 言語での真偽値（0
または 1）の扱いを試す、良い問題ですね！

結論から言うと、あなたの回答はすべて正解です！素晴らしいです！😊

せっかくなので、論理演算子の優先順位と評価の順序、そして C
言語のゼロ以外の値はすべて真とみなすルールに焦点を当てて、それぞれの問題の評価プロセスを解説しますね。

💻 C言語 論理演算子の評価プロセス
(a) i = 10; j = 5; printf("%d\n", !i < j);
あなたの答え: 1 → 正解です。

評価プロセス
優先順位: 単項演算子である論理 NOT (!) は、関係演算子 (<)
より優先順位が高いです。

式は (!i) < j と評価されます。

ステップ 1: !i の評価

i=10 はゼロではないため真です。

!10 は偽となり、C 言語では 0 に評価されます。

式は 0 < j となります。

ステップ 2: 0 < j の評価

0<5 は真です。

C 言語では 1 に評価されます。

出力は 1 です。

(b) i = 2; j = 1; printf("%d\n", !!i + !j);
あなたの答え: 1 → 正解です。

評価プロセス
優先順位: 論理 NOT (!) は、加算 (+) より優先順位が高いです。

式は (!!i) + (!j) と評価されます。

ステップ 1: !!i の評価

!i: i=2 は真 → 0

!!i: 0 は偽 → 1

ステップ 2: !j の評価

!j: j=1 は真 → 0

ステップ 3: 加算の評価

式は 1+0 となります。

結果は 1 です。

出力は 1 です。

(c) i = 5; j = 0; k = -5; printf("%d\n", i && j || k);
あなたの答え: 1 → 正解です。

評価プロセス
優先順位: 論理 AND (&&) は、論理 OR (||) より優先順位が高いです。

式は (i && j) || k と評価されます。

短絡評価 (Short-Circuit Evaluation): 論理演算子には短絡評価の仕組みがあります。

ステップ 1: i && j の評価

i=5 は真ですが、j=0 は偽です。

i && j は偽となり、0 に評価されます。

式は 0 || k となります。

ステップ 2: 0 || k の評価

k=−5 はゼロではないため真です。

0 || -5 は真です。

C 言語では 1 に評価されます。

出力は 1 です。

(d) i = 1; j = 2; k = 3; printf("%d\n", i < j || k);
あなたの答え: 1 → 正解です。

評価プロセス
優先順位: 関係演算子 (<) は、論理 OR (||) より優先順位が高いです。

式は (i < j) || k と評価されます。

ステップ 1: i < j の評価

1<2 は真です。

C 言語では 1 に評価されます。

式は 1 || k となります。

ステップ 2: 1 || k の評価

論理 OR の左側が既に 1 (真) なので、短絡評価により右側 (k) は評価されません。

式全体は真となり、C 言語では 1 に評価されます。

出力は 1 です。

💡 C言語のベストプラクティス：短絡評価
(c) と (d) の解説にもあった「短絡評価」は、C
言語において効率的なコーディングのためのベストプラクティスです。

&& (AND): 左辺が偽（0）なら、右辺は評価せずに全体を偽（0）と確定する。

|| (OR): 左辺が真（1）なら、右辺は評価せずに全体を真（1）と確定する。

この仕組みを理解しておくと、ポインタの参照前に NULL
チェックをしたり、処理負荷の高い関数の実行をスキップしたりなど、実務で非常に役立ちますよ！

すべての問題に正解されていて、論理演算子の理解が深まっているのが分かります。この調子で
C 言語の学習を続けてくださいね！✨
 */

#include <stdio.h>

int main(void) {
  int i, j, k;

  i = 10;
  j = 5;
  printf("(a) %d\n", !i < j);

  i = 2;
  j = 1;
  printf("(b) %d\n", !!i + !j);

  i = 5;
  j = 0;
  k = -5;
  printf("(c) %d\n", i && j || k);

  i = 1;
  j = 2;
  k = 3;
  printf("(d) %d\n", i < j || k);

  return 0;
}
