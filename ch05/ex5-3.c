/* C Programming A Modern Approach ex5-3.c
 *
 * The following program fragments illustrate the short-circuit behavior of
 * logical expressions. Show the output produced by each, assuming that i, j,
 * and k are int variables.
 *
 */

#include <stdio.h>

int main(void) {
  int i, j, k;

  // (a)
  i = 3;
  j = 4;
  k = 5;
  printf("(a) %d \n", i < j || ++j < k);
  printf("    %d %d %d\n", i, j, k);

  //(b)
  i = 7;
  j = 8;
  k = 9;
  printf("(b) %d \n", i - 7 && j++ < k);
  printf("%d %d %d\n", i, j, k);

  //(c)
  i = 7;
  j = 8;
  k = 9;
  printf("(c) %d \n", (i = j) || (j = k));
  printf("%d %d %d\n", i, j, k);

  //(d)
  i = 1;
  j = 1;
  k = 1;
  printf("(d) %d \n", ++i || ++j && ++k);
  printf("%d %d %d\n", i, j, k);

  return 0;
}

/* My Answers:
 * (a) 1            1
 *     3 5 5        3 4 5 : ++jは先に i < jが成立しているので評価されない
 * (b) 0            0
 *     7 9 9        7 8 9 : i - 7が0なので式全体がfalse
 * したがってj++は評価されない (c) 0            1  :  i = jは代入。結果は8。j =
 * k も代入　結果は9 7 8 9        8 8 9 : i = jの時点で式が成立。j = k
 * は評価されない (d) 1 2 2 2        2 1 1 : ++1の時点で式が成立。++j
 * ++kは評価されない。
 *
 * 💻 C言語 短絡評価と副作用の評価
この問題の鍵は、論理演算子 (|| や &&)
の左辺の結果が確定した場合、右辺は評価されないというルールにあります。右辺に含まれるインクリメント
(++) などの副作用も、評価がスキップされれば実行されません。

(a) i < j || ++j < k
初期値: i=3, j=4, k=5

左辺 i < j を評価:

3<4 は 真 (True) です。→ 1

短絡評価:

論理 OR (||) は、左辺が真であれば、式全体が真と確定するため、右辺の ++j < k
は評価されません。

右辺の ++j は実行されません。

結果:

式全体の値は 1 です。

j の値は 4 のままです。

出力項目	あなたの回答	正しい回答
printf 結果	1	1
i,j,k の値	3 5 5	3 4 5

⚠ 間違い: あなたの回答では j が 5 に変化していますが、短絡評価により j
はインクリメントされず 4 のままです。

(b) i - 7 && j++ < k
初期値: i=7, j=8, k=9

左辺 i - 7 を評価:

7−7 は 0 です。→ 偽 (False)

短絡評価:

論理 AND (&&) は、左辺が偽であれば、式全体が偽と確定するため、右辺の j++ < k
は評価されません。

右辺の j++ は実行されません。

結果:

式全体の値は 0 です。

j の値は 8 のままです。

出力項目	あなたの回答	正しい回答
printf 結果	0	0
i,j,k の値	7 9 9	7 8 9

⚠ 間違い: あなたの回答では j が 9 に変化していますが、短絡評価により j++
は実行されず 8 のままです。

(c) (i = j) || (j = k)
初期値: i=7, j=8, k=9

左辺 (i = j) を評価:

j の値 8 が i に代入されます。→ i=8

代入演算子の値は代入後の値なので、この式の結果は 8 です。→ 真 (True)

短絡評価:

論理 OR (||) は、左辺が真であれば、式全体が真と確定するため、右辺の (j = k)
は評価されません。

右辺の (j=k) は実行されません。

結果:

式全体の値は、真を表す 1 です。

j の値は 8 のままです。

出力項目	あなたの回答	正しい回答
printf 結果	0	1
i,j,k の値	7 8 9	8 8 9

⚠ 間違い: 式全体の結果は 1 です。また、左辺の代入は行われるため、i は 8
に変わります。

(d) ++i || ++j && ++k
初期値: i=1, j=1, k=1

左端 ++i を評価:

i がインクリメントされ、i=2 になります。

この式の結果は 2 です。→ 真 (True)

短絡評価:

論理 OR (||) の左辺が真と確定したため、右側の式全体 ++j && ++k
は評価されません。

++j も ++k も実行されません。

結果:

式全体の値は 1 です。

j と k の値は 1 のままです。

出力項目	あなたの回答	正しい回答
printf 結果	1	1
i,j,k の値	2 2 2	2 1 1

⚠ 間違い: あなたの回答では j と k が 2 に変化していますが、短絡評価により j も k
もインクリメントされず 1 のままです。

📋 まとめ
短絡評価では、論理演算子の左側が評価された結果、全体の真偽が確定すれば、右側の式に副作用が含まれていても、その副作用は発生しないという点に注意が必要です。

設問	printf 結果	i の最終値	j の最終値	k の最終値
(a)	1	3	4	5
(b)	0	7	8	9
(c)	1	8	8	9
(d)	1	2	1	1

この短絡評価のルールは、実務で C 言語や Bash
の条件分岐を書く際に、効率と安全なコード（例：ポインタの NULL
チェックなど）を両立させるためのベストプラクティスとなります。
 */
