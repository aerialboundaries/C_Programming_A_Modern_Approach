/* C Programming A Modern Approach ex 5-1.c
 *
 * Q: The following program fragments illustrate the relational and equality
 * operatiors.  Show the output produced by each, assuming that i, j, and k are
 * int valiables.
 *
 * (a) i = 2; j = 3
 *      k = i * j ==6;
 *      printf(:%d, k);
 * (b) i = 5; j = 10; k = 1;
 *      printf("%d", k > i  < j);
 * (c) i = 3; j = 2; k = 1;
 *      printf("d", i < j == J < k);
 * (d) i = 3; j = 4; k = 5;
 *      printf("%d", i % j + i < k);
 *
 *  My answers:
 *  (a) 1
 *  (b) 1
 *  (c) 1
 *  (d) 4
 *
 *  Gemini
 *  お示しいただいた C
言語の演算子の問題と、それに対するあなたの答えを拝見しました。あなたが重点的に学習されている
C 言語の知識を試す良い問題ですね！😊

結論から言うと、いくつかの答えは正しくありません。特に、C
言語の演算子の優先順位と結合規則、そして真偽値の扱いを理解することがポイントになります。

プロの講師として、それぞれの問題について丁寧に、ベストプラクティスとなる演算子の評価順序を交えて詳しく解説しますね。

💻 C言語の演算子の問題の評価と解説
各設問について、正しい出力と、そこに至るまでの演算の流れを追っていきましょう。

(a) i = 2; j = 3; k = i * j == 6;
あなたの答え: 1 → 正しいです。

評価プロセス
演算子の優先順位: *（乗算）は ==（等価比較）より優先順位が高いです。

k = (i * j) == 6; と評価されます。

i * j → 2×3=6

k = 6 == 6;

6 == 6 は真（true）なので、C 言語では 1 に評価されます。

k に 1 が代入され、printf の出力は 1 となります。

(b) i = 5; j = 10; k = 1; printf("%d", k > i < j);
あなたの答え: 1 → 正しいです。

評価プロセス
演算子の結合規則: 関係演算子 (>, <, == など)
は、同じ優先順位の場合、左から右へ結合します。

printf("%d", (k > i) < j); と評価されます。

ステップ 1: k > i の評価

1>5 は偽（false）です。

C 言語では 0 に評価されます。

式は 0 < j となります。

ステップ 2: 0 < j の評価

0<10 は真（true）です。

C 言語では 1 に評価されます。

printf の出力は 1 となります。

(c) i = 3; j = 2; k = 1; printf("%d", i < j == j < k);
あなたの答え: 1 → 正しくありません。 正しい出力は 0 です。

評価プロセス
演算子の優先順位と結合規則:

<（より小）は ==（等価比較）より優先順位が高いです。

同じ優先順位の < は左から右へ結合します。

式は printf("%d", (i < j) == (j < k)); と評価されます。

左側: i < j の評価

3<2 は偽（false）です。

C 言語では 0 に評価されます。

右側: j < k の評価

2<1 は偽（false）です。

C 言語では 0 に評価されます。

全体の評価

式は 0 == 0 となります。

0==0 は真（true）です。

C 言語では 1 に評価されます。

printf の出力は 1 となる...と見えますが、問題文の変数が小文字の j
になっています。

⚠ 補足：問題文のタイプミス

問題文のコードは printf("d", i < j == J < k); となっており、J
が大文字になっています。

もし J が未定義の変数であればコンパイルエラーとなります。

もし J が j のタイプミスだった場合、上記のように結果は 1
となり、あなたの回答は正しくなります。

ここでは、最も妥当なケースとして**J は j
のタイプミスである**と仮定して、評価を続けます。

🚨 修正：あなたの回答が 1 である理由
あなたが 1 と答えたのは、おそらく J を j
と解釈したためでしょう。その解釈であれば、あなたの答えは正解です。私もこの問題の意図として、その解釈が正しいと考えます。

(d) i = 3; j = 4; k = 5; printf("%d", i % j + i < k);
あなたの答え: 4 → 正しくありません。 正しい出力は 1 です。

評価プロセス
演算子の優先順位: C 言語では () が最優先ですが、今回は**%（剰余）が
+（加算）より高く**、+（加算）が <（より小）より高く評価されます。

式は printf("%d", (i % j) + i) < k); と評価されます。

ステップ 1: i % j の評価

3%4 → 3 を 4 で割った余りは 3 です。

ステップ 2: 3 + i の評価

3+3=6

式は 6 < k となります。

ステップ 3: 6 < k の評価

6<5 は偽（false）です。

C 言語では 0 に評価されます。

printf の出力は 0 となります。

⚠ あなたの回答が 4 になった理由の推測

あなたは、おそらく i%j+i の部分の結果 6 を出力すると考えたのではないでしょうか？
しかし、式全体には最後に**< k
という比較演算子**が含まれているため、最終的な出力は真偽値の 0 または 1
になります。
 */

#include <stdio.h>

int main(void) {

  int i, j, k;

  i = 2;
  j = 3;
  k = i * j == 6;
  printf("(a) %d\n", k);
  i = 5;
  j = 10;
  k = 1;
  printf("(b) %d\n", k > i < j);
  i = 3;
  j = 2;
  k = 1;
  printf("(c) %d\n", i < j == j < k);
  i = 3;
  j = 4;
  k = 5;
  printf("(d) %d\n", i % j + i < k);
}
